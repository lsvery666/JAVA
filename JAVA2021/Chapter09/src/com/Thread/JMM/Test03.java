package com.Thread.JMM;

/*
j = i++：
先把i从主内存（常量）中加载到局部变量表，
然后把i的值加载到操作数栈中，
然后在局部变量表中i自增1（自增操作要用到寄存器，先把值读入寄存器，再加一，再放回，最终写回到主内存），
然后把操作数栈顶的值赋给j

j = ++i：
先把i从主内存中（常量）加载到局部变量表，
然后在局部变量表中i自增1（最终写回到主内存），
再把i的值加载到操作数栈中，
再把操作数栈顶的值赋给j
 */

/*
volatile不能保证原子性，i++不是一个原子操作。
 */


public class Test03 {
    public volatile int inc = 0;

    public void increase(){
        inc++;
    }

    public static void main(String[] args) {
        Test03 test03 = new Test03();
        for(int i=0;i<10;i++){
            new Thread(){
                @Override
                public void run() {
                    for (int j=0;j<1000;j++) {
                        test03.increase();
                    }
                }
            }.start();
        }

        while (Thread.activeCount()>2){
            Thread.yield();

        }

        // 输出不为10000
        System.out.println(test03.inc);
    }
}
/*
假如某个时刻变量inc的值为10，

线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；

然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，
由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，
所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，
所以线程2会直接去主存读取inc的值，发现inc的值时10，
然后进行加1操作，并把11写入工作内存，最后写入主存。

然后线程1接着进行加1操作，由于已经读取了inc的值，
注意此时在线程1的工作内存中inc的值仍然为10，
所以线程1对inc进行加1操作后inc的值为11，
然后将11写入工作内存，最后写入主存。

那么两个线程分别进行了一次自增操作后，inc只增加了1。

解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？
然后其他线程去读就会读到新的值，对，这个没错。
这个就是上面的happens-before规则中的volatile变量规则，
但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。
然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，
但是线程1没有进行修改，所以线程2根本就不会看到修改的值。

根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。
 */