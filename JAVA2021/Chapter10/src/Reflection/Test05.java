package Reflection;

/*
什么时候会发生类初始化
    类的主动引用（一定会发生类的初始化）
        当虚拟机启动时，先初始化main方法所在的类
        new一个类的对象
        调用类的静态成员（除了final常量）和静态方法
        使用java.lang.reflect包的方法对类进行反射调用
        当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
    类的被动引用（不会发生类的初始化）
        当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用访问父类的静态变量，不会导致子类初始化
        通过数组定义类引用，不会触发此类的初始化
        引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中）
 */

public class Test05 {
    public static void main(String[] args) {
        // 不会发生B类的初始化
        // 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用访问父类的静态变量，不会导致子类初始化
        //System.out.println(B.m);

        // 通过数组定义类引用，不会触发此类的初始化
        // B[] bs = new B[5];
        // bs[0].n = 1;     // 加上这句会触发此类的初始化

        // 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中）
        System.out.println(B.M);
    }
}
